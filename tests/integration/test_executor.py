import pytest
from docker.errors import DockerException
from loguru import logger

from bench_mac.docker.manager import DockerManager
from bench_mac.executor import execute_submission
from bench_mac.metrics import calculate_metrics
from bench_mac.models import BenchmarkInstance, CommandsConfig, Submission

# A deliberately malformed patch that is guaranteed to fail application.
# It tries to remove a line that is unlikely to exist in that exact form.
BAD_PATCH = """
diff --git a/src/app/app.component.ts b/src/app/app.component.ts
index 1234567..abcdefg 100644
--- a/src/app/app.component.ts
+++ b/src/app/app.component.ts
@@ -1,5 +1,5 @@
-This line does not exist and will cause the patch to fail.
+This is the new line that will never be applied.
"""


@pytest.fixture(scope="module")
def docker_manager() -> DockerManager:
    """Provides a DockerManager instance, skipping tests if Docker is unavailable."""
    try:
        return DockerManager()
    except DockerException:
        pytest.skip("Docker daemon is not running. Skipping integration tests.")


@pytest.fixture(scope="module")
def test_instance() -> BenchmarkInstance:
    """Provides a real, known-good benchmark instance for testing."""
    # This instance is simple and its repository is small, making it ideal for testing.
    return BenchmarkInstance(
        instance_id="angular2-hn_v18_to_v19",
        repo="SuperMuel/angular2-hn",
        base_commit="e5a358f",  # Corresponds to v18
        source_angular_version="18",
        target_angular_version="19",
        target_node_version="20.11.0",
        commands=CommandsConfig(
            install="npm install",
            build="ng build --configuration production",
        ),
    )


@pytest.fixture(scope="module")
def silver_submission(test_instance: BenchmarkInstance) -> Submission:
    """
    Provides a known-good ("silver") submission for the test_instance.

    Raises
    ------
    FileNotFoundError
        If the required patch file does not exist, indicating a test setup error.
    """
    from bench_mac.config import settings

    patch_file = settings.silver_patches_dir / f"{test_instance.instance_id}.patch"

    if not patch_file.exists():
        error_message = (
            f"\n\nRequired silver patch not found at: {patch_file}\n\n"
            "This is a test setup error. To fix it:\n\n"
            "1. Ensure the patch has been generated by running:\n"
            "   uv run python scripts/generate_silvers.py\n\n"
            "2. Verify that the instance_id '{test_instance.instance_id}' used in this"
            " test has a corresponding entry in the SILVER_SOLUTIONS map within the"
            " 'scripts/generate_silvers.py' script."
        )
        raise FileNotFoundError(error_message)

    patch_content = patch_file.read_text()
    return Submission(instance_id=test_instance.instance_id, model_patch=patch_content)


@pytest.mark.integration
class TestExecuteSubmission:
    def test_successful_patch_application(
        self,
        docker_manager: DockerManager,
        test_instance: BenchmarkInstance,
        silver_submission: Submission,
    ) -> None:
        """
        Verify that a known-good patch is evaluated as successful.
        """
        # --- ACT ---
        trace = execute_submission(
            test_instance,
            silver_submission,
            docker_manager,
            logger=logger,
        )
        metrics = calculate_metrics(trace)

        # --- ASSERT ---
        assert trace is not None
        assert len(trace.steps) > 0

        # The primary metric for this test
        assert metrics.patch_application_success is True

        # Check that the execution trace shows successful patch application
        patch_apply_step = None
        for step in trace.steps:
            if "git apply -p0" in step.command and "--check" not in step.command:
                patch_apply_step = step
                break

        assert patch_apply_step is not None
        assert patch_apply_step.success
        assert "error" not in patch_apply_step.stderr.lower()
        assert "fail" not in patch_apply_step.stderr.lower()

    def test_failed_patch_application(
        self,
        docker_manager: DockerManager,
        test_instance: BenchmarkInstance,
    ) -> None:
        """
        Verify that a deliberately bad patch is evaluated as a failure.
        """
        # --- ARRANGE ---
        bad_submission = Submission(
            instance_id=test_instance.instance_id, model_patch=BAD_PATCH
        )

        # --- ACT ---
        trace = execute_submission(
            test_instance,
            bad_submission,
            docker_manager,
            logger=logger,
        )
        metrics = calculate_metrics(trace)

        # --- ASSERT ---
        assert trace is not None
        assert len(trace.steps) > 0

        # The primary metric for this test
        assert metrics.patch_application_success is False

        # Check that the execution trace shows failed patch application
        patch_check_step = None
        for step in trace.steps:
            if "git apply --check" in step.command:
                patch_check_step = step
                break

        assert patch_check_step is not None
        assert not patch_check_step.success
        assert (
            "error" in patch_check_step.stderr.lower()
            or "patch does not apply" in patch_check_step.stderr.lower()
            or patch_check_step.exit_code != 0
        )
